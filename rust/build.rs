use chrono::prelude::*;
use dotenv::dotenv;
use indexmap::IndexMap;
use std::env;
use std::fs::{self};
use std::path::Path;
use toml::Value;

include!("src/config.rs");

// TODO: Replace "__AUTOGEN__" with `embed-resources` crate (https://crates.io/crates/embed-resources)

static AUTOGEN_FILE_HEADER: &str = "// IMPORTANT: This file is automatically generated and should *not* be committed to source control.\n\n";

fn main() {
    dotenv().ok();

    // Handle environment variables for encryption
    handle_encryption_env_vars();

    // Load and process the TOML configuration
    let ticker_vector_configs_toml = load_ticker_vector_toml_config("ticker_vector_configs.toml");
    let ticker_vector_configs_rust_code =
        generate_ticker_vector_config_rust_code(&ticker_vector_configs_toml);
    write_generated_code(
        &ticker_vector_configs_rust_code,
        "__AUTOGEN__generated_ticker_vectors_config.rs",
    );

    // Generate the compilation time constant file
    generate_compilation_time_constant();
}

fn generate_compilation_time_constant() {
    // Get the current time as a human-readable string
    let now: DateTime<Utc> = Utc::now();
    let formatted_time = now.to_rfc3339(); // Format as an ISO 8601 string

    // Generate the Rust code
    let code = format!(
        "pub const RUST_COMPILATION_TIME: &str = \"{}\";",
        formatted_time
    );

    // Use the existing write_generated_code function to write the code to a file
    write_generated_code(&code, "__AUTOGEN__compilation_time.rs");
}

/// Handles the environment variables for encryption and generates Rust code.
fn handle_encryption_env_vars() {
    if let (Ok(encrypted_password), Ok(_key), Ok(iv)) = (
        env::var("ENCRYPTED_PASSWORD"),
        env::var("KEY"),
        env::var("IV"),
    ) {
        // Convert the comma-separated string to a byte array
        let encrypted_password_bytes: Vec<u8> = parse_env_variable_to_bytes(&encrypted_password)
            .expect("Failed to parse ENCRYPTED_PASSWORD");
        // let key_bytes: Vec<u8> = parse_env_variable_to_bytes(&key).expect("Failed to parse KEY");
        let iv_bytes: Vec<u8> = parse_env_variable_to_bytes(&iv).expect("Failed to parse IV");

        // Encode the byte arrays as hex strings
        let encrypted_password_hex: String = hex::encode(encrypted_password_bytes);
        let iv_hex: String = hex::encode(iv_bytes);

        // Build the Rust code as a string
        let mut code = String::new();

        let encryption_matrices_code = CODE_MATRIX_FUNCTION_TEMPLATE
            .replace(
                "{{CHARACTER_CODE_MATRIX}}",
                &build_character_codes_matrix(&encrypted_password_hex),
            )
            .replace("{{IV_CODE_MATRIX}}", &build_character_codes_matrix(&iv_hex));

        code.push_str(&encryption_matrices_code);

        // Use the write_generated_code function to write the code to a file
        write_generated_code(&code, "__AUTOGEN__generated_password.rs");
    } else {
        panic!("ENCRYPTED_PASSWORD, KEY, or IV not set");
    }
}

/// Loads a TOML configuration file and returns it as an `IndexMap`.
fn load_ticker_vector_toml_config(file_path: &str) -> IndexMap<String, Value> {
    let config_content = fs::read_to_string(file_path)
        .unwrap_or_else(|_| panic!("Failed to read configuration file: {}", file_path));
    let parsed_config: Value = config_content
        .parse::<Value>()
        .expect("Invalid TOML format");

    parsed_config
        .get("ticker_vector_config")
        .and_then(|v| v.as_table())
        .map(|table| table.iter().map(|(k, v)| (k.clone(), v.clone())).collect())
        .unwrap_or_else(IndexMap::new)
}

fn parse_ticker_vector_config(
    key: &str,
    sort_order: usize,
    sub_table: &toml::Table,
) -> Option<String> {
    let (
        path,
        last_training_time,
        vector_dimensions,
        training_sequence_length,
        training_data_sources,
    ) = match (
        sub_table.get("path").and_then(|v| v.as_str()),
        sub_table.get("last_training_time").and_then(|v| v.as_str()),
        sub_table
            .get("vector_dimensions")
            .and_then(|v| v.as_integer()),
        sub_table
            .get("training_sequence_length")
            .and_then(|v| v.as_integer()),
        sub_table
            .get("training_data_sources")
            .and_then(|v| v.as_array()),
    ) {
        (Some(p), Some(t), Some(vd), Some(tsl), Some(tds)) => (p, t, vd, tsl, tds),
        _ => return None,
    };

    let description = sub_table
        .get("description")
        .and_then(|v| v.as_str())
        .map_or("None".to_string(), |desc| format!("Some(\"{}\")", desc));

    let sources_str = training_data_sources
        .iter()
        .filter_map(|v| v.as_str())
        .map(|s| format!("\"{}\"", s))
        .collect::<Vec<String>>()
        .join(", ");

    Some(format!(
        "    map.insert(\"{}\", TickerVectorConfig {{ key: \"{}\", sort_order: {}, path: \"{}\", description: {}, last_training_time: \"{}\", vector_dimensions: {}, training_sequence_length: {}, training_data_sources: vec![{}] }});\n",
        key, key, sort_order, path, description, last_training_time, vector_dimensions, training_sequence_length, sources_str
    ))
}

fn generate_ticker_vector_config_rust_code(config: &IndexMap<String, Value>) -> String {
    let mut code = String::new();
    code.push_str("use indexmap::IndexMap;\n");
    code.push_str("use crate::config::TickerVectorConfig;\n\n");

    code.push_str(
        "pub fn get_ticker_vectors_map() -> IndexMap<&'static str, TickerVectorConfig> {\n",
    );
    code.push_str("    let mut map = IndexMap::new();\n");

    for (sort_order, (key, value)) in config.iter().enumerate() {
        if let Some(sub_table) = value.as_table() {
            if let Some(config_str) = parse_ticker_vector_config(key, sort_order, sub_table) {
                code.push_str(&config_str);
            }
        }
    }

    code.push_str("    map\n");
    code.push_str("}\n");

    code
}

/// Writes the generated Rust code to a file in the output directory.
fn write_generated_code(code: &str, file_name: &str) {
    // Concatenate the file header with the generated code
    let full_code = format!("{}{}", AUTOGEN_FILE_HEADER, code);

    // Define the path to the src directory
    let dest_path = Path::new("src").join(file_name);

    // Write the full code (header + generated code) to the specified file in the src directory
    fs::write(dest_path, full_code).expect("Failed to write generated code");
}

/// Parses an environment variable into a byte array.
fn parse_env_variable_to_bytes(env_var: &str) -> Result<Vec<u8>, Box<dyn std::error::Error>> {
    env_var
        .split(',')
        .map(|s| {
            s.trim()
                .parse::<u8>()
                .map_err(|e: std::num::ParseIntError| {
                    eprintln!("Failed to parse '{}': {}", s, e);
                    Box::new(e) as Box<dyn std::error::Error>
                })
        })
        .collect()
}

/// Builds a character codes matrix from a string.
fn build_character_codes_matrix(input: &str) -> String {
    let chars: Vec<u32> = input.chars().map(|c| c as u32).collect();
    let mut result = String::new();
    result.push_str("[\n");
    for chunk in chars.chunks(8) {
        result.push_str("    [");
        let row: Vec<String> = chunk.iter().map(|&c| c.to_string()).collect();
        result.push_str(&row.join(", "));
        result.push_str("],\n");
    }
    result.push(']');
    result
}

static CODE_MATRIX_FUNCTION_TEMPLATE: &str = r#"
pub fn get_encrypted_password() -> String {{
    let mut s = String::new();
    let codes = {{CHARACTER_CODE_MATRIX}};
    for row in &codes {{
        for &code in row {{
            s.push(char::from_u32(code).unwrap());
        }}
    }}
    s
}}

pub fn get_iv() -> String {{
    let mut s = String::new();
    let codes = {{IV_CODE_MATRIX}};
    for row in &codes {{
        for &code in row {{
            s.push(char::from_u32(code).unwrap());
        }}
    }}
    s
}}
"#;
