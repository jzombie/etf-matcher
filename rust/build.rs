use dotenv::dotenv;
use std::env;
use std::fs::{self, File};
use std::io::Write;
use std::path::Path;
use toml::Value;

static AUTOGEN_FILE_HEADER: &str = "// IMPORTANT: This file is automatically generated and should *not* be committed to source control.\n\n";

fn main() {
    dotenv().ok();

    // Handle environment variables for encryption
    handle_encryption_env_vars();

    // Load and process the TOML configuration
    let config = load_toml_config("ticker_vectors_config.toml");
    let rust_code = generate_rust_code_from_toml(&config);
    write_generated_code(&rust_code, "__AUTOGEN__generated_ticker_vectors_config.rs");
}

/// Handles the environment variables for encryption and generates Rust code.
fn handle_encryption_env_vars() {
    if let (Ok(encrypted_password), Ok(key), Ok(iv)) = (
        env::var("ENCRYPTED_PASSWORD"),
        env::var("KEY"),
        env::var("IV"),
    ) {
        // Convert the comma-separated string to a byte array
        let encrypted_password_bytes: Vec<u8> = parse_env_variable_to_bytes(&encrypted_password)
            .expect("Failed to parse ENCRYPTED_PASSWORD");
        let key_bytes: Vec<u8> = parse_env_variable_to_bytes(&key).expect("Failed to parse KEY");
        let iv_bytes: Vec<u8> = parse_env_variable_to_bytes(&iv).expect("Failed to parse IV");

        // Encode the byte arrays as hex strings
        let encrypted_password_hex: String = hex::encode(encrypted_password_bytes);
        let _key_hex: String = hex::encode(key_bytes); // Not used directly
        let iv_hex: String = hex::encode(iv_bytes);

        // Write the encrypted password, key, and IV to a Rust source file
        let mut file: File =
            File::create("src/__AUTOGEN__generated_password.rs").expect("Could not create file");

        write!(file, "{}", AUTOGEN_FILE_HEADER).expect("Could not write to file");

        let result = CODE_MATRIX_FUNCTION_TEMPLATE
            .replace(
                "{{CHARACTER_CODE_MATRIX}}",
                &build_character_codes_matrix(&encrypted_password_hex),
            )
            .replace("{{IV_CODE_MATRIX}}", &build_character_codes_matrix(&iv_hex));

        write!(file, "{}", result).expect("Could not write to file");
    } else {
        panic!("ENCRYPTED_PASSWORD, KEY, or IV not set");
    }
}

// TODO: Rename
//
/// Loads a TOML configuration file and returns it as a `Value`.
fn load_toml_config(file_path: &str) -> Value {
    let config_content = fs::read_to_string(file_path)
        .unwrap_or_else(|_| panic!("Failed to read configuration file: {}", file_path));
    let parsed_config = config_content
        .parse::<Value>()
        .expect("Invalid TOML format");
    println!("Parsed TOML: {:?}", parsed_config); // Debug print
    parsed_config
}

// TODO: Rename
/// Generates Rust code from the TOML configuration.
fn generate_rust_code_from_toml(config: &Value) -> String {
    let mut code = String::new();
    code.push_str(AUTOGEN_FILE_HEADER);
    code.push_str("use std::collections::HashMap;\n\n");

    // Define the struct
    code.push_str("#[derive(Clone)]\n");
    code.push_str("pub struct TickerVectorConfig {\n");
    code.push_str("    pub path: &'static str,\n");
    code.push_str("    #[allow(dead_code)]\n"); // Make usage of `description` optional
    code.push_str("    pub description: Option<&'static str>,\n");
    code.push_str("}\n\n");

    // Define the function
    code.push_str(
        "pub fn get_ticker_vectors_map() -> HashMap<&'static str, TickerVectorConfig> {\n",
    );
    code.push_str("    let mut map = HashMap::new();\n");

    if let Some(table) = config.get("ticker_vectors").and_then(|v| v.as_table()) {
        for (key, value) in table {
            if let Some(sub_table) = value.as_table() {
                if let Some(path) = sub_table.get("path").and_then(|v| v.as_str()) {
                    let description = sub_table.get("description").and_then(|v| v.as_str());
                    let description_str = match description {
                        Some(desc) => format!("Some(\"{}\")", desc),
                        None => "None".to_string(),
                    };
                    code.push_str(&format!(
                        "    map.insert(\"{}\", TickerVectorConfig {{ path: \"{}\", description: {} }});\n",
                        key, path, description_str
                    ));
                }
            }
        }
    }

    code.push_str("    map\n");
    code.push_str("}\n");

    code
}

// TODO: Rename
//
/// Writes the generated Rust code to a file in the output directory.
fn write_generated_code(code: &str, file_name: &str) {
    // Define the path to the src directory
    let dest_path = Path::new("src").join(file_name);

    // Write the generated code to the specified file in the src directory
    fs::write(dest_path, code).expect("Failed to write generated code");
}

/// Parses an environment variable into a byte array.
fn parse_env_variable_to_bytes(env_var: &str) -> Result<Vec<u8>, Box<dyn std::error::Error>> {
    env_var
        .split(',')
        .map(|s| {
            s.trim()
                .parse::<u8>()
                .map_err(|e: std::num::ParseIntError| {
                    eprintln!("Failed to parse '{}': {}", s, e);
                    Box::new(e) as Box<dyn std::error::Error>
                })
        })
        .collect()
}

/// Builds a character codes matrix from a string.
fn build_character_codes_matrix(input: &str) -> String {
    let chars: Vec<u32> = input.chars().map(|c| c as u32).collect();
    let mut result = String::new();
    result.push_str("[\n");
    for chunk in chars.chunks(8) {
        result.push_str("    [");
        let row: Vec<String> = chunk.iter().map(|&c| c.to_string()).collect();
        result.push_str(&row.join(", "));
        result.push_str("],\n");
    }
    result.push(']');
    result
}

static CODE_MATRIX_FUNCTION_TEMPLATE: &str = r#"
pub fn get_encrypted_password() -> String {{
    let mut s = String::new();
    let codes = {{CHARACTER_CODE_MATRIX}};
    for row in &codes {{
        for &code in row {{
            s.push(char::from_u32(code).unwrap());
        }}
    }}
    s
}}

pub fn get_iv() -> String {{
    let mut s = String::new();
    let codes = {{IV_CODE_MATRIX}};
    for row in &codes {{
        for &code in row {{
            s.push(char::from_u32(code).unwrap());
        }}
    }}
    s
}}
"#;
